# GGPOとは何か？

2009年に作成されたGGPOネットワーキングSDKは、ピアツーピアゲームでのロールバックネットワーキングの使用を開拓しました。 非常に正確な入力とフレームの完全な実行を必要とする速いペースの単収縮スタイルのゲームでネットワーク遅延を隠すために特別に設計されています。

従来の手法では、プレーヤーの入力に遅延を追加することでネットワークの送信時間を考慮し、結果としてゲームの動きが鈍くなります。 ロールバックネットワーキングは、入力予測と投機的実行を使用して、プレーヤーの入力を直ちにゲームに送信し、ゼロ遅延ネットワークの錯覚を与えます。ロールバックネットコードを用いて、プレイヤーがオフラインでプレイすることで蓄積した筋肉のメモリ、タイミング、リアクション、およびをビジュアルキューとオーディオキューオンラインでも直接に利用できます。 GGPOネットワーキングSDKは、ロールバックネットワーキングをできるだけ簡単に、新規および既存のゲームに組み込むことができるように設計されています。


# 仕組みは？

ロールバックネットワーキングは、完全に決定的なピアツーピアエンジンに統合されるように設計されています。完全な決定論により、単に同じ入力をフィードするだけで、すべてのプレイヤーコンピューターで同じ方法でゲームがプレイされることが保証されます。これを実現する1つの方法は、ネットワーク経由ですべてのプレーヤーの入力を交換し、すべてのプレーヤーがピアからすべての入力を受け取ったときにのみゲームプレイロジックのフレームを実行することです。そうすると、多くの場合、結果としてゲームプレイの反応が遅く、応答が遅くなります。ネットワークを介して入力を取得するのに時間がかかるほど、ゲームは遅くなります。


## インプットディレイによるネットワーキング使用の場合

### 理論的に…

以下の系統図をご覧ください。統計図に理想的な0msの遅延のネットワークで２つのクライエントが同期されています。 プレヤー１の入力とゲームステートは青い色で、プレヤー２のは赤い色で、ネットワークレイヤが緑色で記述されています。黒い矢はシステムを経由している入力とステート遷移を表します。フレームずつは破線で分けられています。統計図はプレヤー１の視点しか見せていませんが、プレヤー２は同一のステップに従っています。

![](images/overview_image1.png)

ゲームエンジンに放送される前、プレヤー１の入力はネットワークレイヤでプレヤー２の入力と併合されます。エンジンは現在のフレームのゲームステートをその入力を使って異動します。プレヤー２は同様、自分の入力とプレヤー１の入力を併合して、組み合わせた入力をゲームエンジンに放送します。ゲームはそのふうに毎フレームをプレヤーインプットによって前のフレームを加工して、続きます。プレヤー１とプレヤー２は同じゲームステートから始まりまして、両方のゲームエンジンに放送した入力が一致していますので、二人のプレヤーのゲームステートは自動的にフレームずつに同期化されています。

### 実践的に…

以上の理想的なネットワークのたとえで、パッケットが遅延なくネットワーク介して転送されているとする。現実はそんあに甘くはない。インフラ性質とプレヤーの間の距離によって、普通のブロードバンド接続で、パッケットを転送するのは５ｍｓから１５０ｍｓがかかります。あなたのゲームが６０FPSでしたら、その遅延は１から９フレームとなります。

ゲームが全てのプレヤーの入力が受け取るまで続けることができませんので、ゲームは１から９フレームまでの遅延をプレヤーの入力に入道しなければならなくなります。

![](images/overview_image3.png)

この例でパケットを転送するにはフレーム３枚が経過する。つまり、第一フレームに送った、リモートのプレヤー２の入力が、プレヤー１のゲームエンジンの三フレーム後にしか到着しません。プレヤー１のゲームエンジンがプレヤー２の入力を受け取る前は続くことができませんので、第一フレームを３フレームで遅延しなければなりません。従って、全部の後続のフレームも３フレームで遅延されています。ネットワークレイヤーは併合した入力を，最大のプレヤーの間に交換されたパケットの片方向輸送時間で遅延しなければなりません。この遅延は多くのゲームタイプのゲームエクスペリエンスに著しい悪影響を与えることになりかねます。

## 入力遅延をロールバックネットワーキングで減縮する

### 投機的実行

GGPOライブラリは、インプットラグを、パケットを転送するに必要な遅延を投機的実行を使って隠すことで防ぎます。次の統計図を見ましょう。

![](images/overview_image2.png)

リモートプレヤーから入力を受け取るのを待つ代わりに、GGPOライブラリは過去の入力に基づいて、リモートプレヤーがどんな入力を入力するのを予測します。GGPOは予測した入力をプレヤー１のロカルノの入力と併合して、直接に併合した入力をゲームエンジンに送ります。そうして、ゲームエンジンは次のフレームを、他のプレヤーの入力が含まれるパケットがまだ受け取れなくても、加工できます。
GGPOの予測が完璧だったら、オンラインプレイはオフラインプレイと同じになります。もちろん誰も未来を予測できません。GGPOは時々、プレヤー２の入力を間違って予測します。上の統計図をもう一回見てください。GGPOがプレヤー２に第一フレームの瞬間に間違っている入力を転送したら、何が起こりますか？そういう時に、プレヤー２のための入力がプレヤー１のゲームとプレヤー２のゲームと異なるようになります。２つのゲームステートが同期が失って、二人のプレヤーが２つの違っている現実に作用するようになってしまいます。動機誤差はプレヤー１が正しい入力を受け取るフレーム４まで認識できませんが、それはもう遅すぎます。
これが、GGPOの機能方法が「投機的実行」と呼ばれている理由です。プレヤーが現在のゲームのフレームのときに見えるものは正しいかもしれませんが、そうでないかもしれません。GGPOがリモートのプレヤーの入力を誤って予測する場合は、そのミスを次のフレームへ続行する前に修正しなければなりません。次の例でその方法を説明します。

### 投機的実行のエラーをロールバックで修正する

GGPOはリモートのプレヤーの入力を過って予測した場合、ロールバックを使用して、クライアントを再同期します。ロールバックというのは、ゲームステートを巻き戻し、プレヤーの入力のより正確な情報によって、新しい結果を予測するプロセスを指します。前のセクションで我々は、予測した、リモート入力１のフレームが誤っている場合では、何が起こるのかについて考えました。GGPOはエラーをどうやって修正するのかを見ましょう。

![](images/overview_image5.png)

GGPOは前のフレームのための予測の品質をリモート入力を受け取るたびにチェックします。前いいたように、GGPOはプレヤー２のはじめのフレームの入力を、プレヤー１の第四フレームまで受け取りません。プレヤー１の第四フレームに、GGPOはネットワークから受け取った入力が予測した入力と一致しないことに機付きます。２つのゲームステートを再同期させるために、GGPOはゲームを間違った入力で三フレームも実行したダメージを取り消さなければなりません。そうするために、ゲームエンジンに、誤って予測した入力を送る前のステートに戻すように要求します（つまり、ゲームエンジンを前のステートへ「ロールバック」させるのです）。前のステートが修復された後、GGPOはゲームエンジンに修正された入力ストリームを使用して、ゲームステートをフレームずつ続行するように要請します。そのリプレーされたフレームは水色で表示されます。あなたのゲームエンジンはそのフレームをできるだけ早く、ユーザーが目に見える影響を与えずにリプレーする必要があります。たとえば、あなたのビデオレンダラーはこれらのフレームを画面に描画しないのがいいです。ゲームのオーディオシステムはオーディオを生成し続けますが、ロールバックが完成するまではサウンドを出力しない方がいいです。ロールバックが完成した後、サウンドサンプルは第Nフレームのサンプルの再生を開始する必要があります。Nとは現在のフレーム番号から、サンプルが生成されたフレーム番号を引いたものです。
ゲームエンジンがGGPOが予測エラーに気づいた前のフレームにたどり付いたら、GGPOはロールバックモードを中止して、ゲームを通常どおり続行します。統計図の第５と６フレームはGGPOの予測が正しい場合に起こることです。ゲームステートが正しいので、ロールバックする必要性がありません。

# コード構造

以下の統計図はGGPOセッションオブジェクトの中の主要な部分とそれらの相互関係を示しています。各コンポーネントの詳細を以下に説明します。

![](images/overview_image4.png)

## GGPOインタフェース

GGPOインターフェースはP2PとSyncTestのバックエンド実装詳細を抽象化します。ggpo_start_sessionまたはggpo_start_synctestのエントリーポイントをコールすると、適切なバックエンドが自動的に作成されます。

## P2Pバックエンド

P2Pバックエンドはプレヤー間のゲームを管理します。ggpo_start_session API呼び出しによって作成されます。含まれているヘルパークラスは大体の努力を実行します。

## ポリングオブジェクト

(統計図に無い)。ポリングオブジェクトは他のコードの中のオブジェクトが使用する登録メカニズムです。このオブジェクトは待機可能のオブジェクトが準備完了になると、タイマーと通知を配信します。たとえば、UDPバックエンドはポリングオブジェクトを利用して、新しいパケットが到着する時に通知を受信します。

## 同期（Sync）オブジェクト

同期オブジェクトは前のNフレームのゲームステートを管理するために利用されます。含まれる予測（prediction）オブジェクトが予測の過ちを通知したら、Syncバックエンドはゲームをより正確なステートに巻き戻し、予測エラーを修正するためにステートをフレームずつ続行します。

## 入力キューオブジェクト

入力キューオブジェクトは全部のローカルか、リモートのプレヤーの入力を管理します。まだ受信されていない入力が要求されたら、入力キューは次の入力を予測して、予測が誤ったら、同期オブジェクトがどこまでロールバックしなければ、ならないことが分かるように、その情報を保存しておきます。求められた場合、入力キューはフレーム遅延も実行します。

## UDPプロトコルオブジェクト

UDPプロトコルオブジェクトは二人のプレヤー間の同期・入力交換プロトコルを処理します。このオブジェクトゲーム入力の圧縮と信頼性のあるUDPレーヤも実装します。全てのUDPプロトコルオブジェクトにはTimeSyncオブジェクトが含まれ、そのオブジェクトをプレヤーの間の時間ずれを推測するために利用しています。

## UDPオブジェクト

UDPオブジェクトは単純なUDPパケットのセンダー・リシーバ。違うプラットフォームへの移植を簡易にするために、UDPプロトコルから孤独されています。

## SyncTestバックエンド

(統計図に無い) SyncTestバックエンドはP2Pバックエンドと同じSyncオブジェクトを使って、実装者のアップリケーションのセーブステートとステッピング機能が決定的に実行していることを確認します。SyncTestの使い方の詳細についてはデベロップメントガイドをご参照ください。
